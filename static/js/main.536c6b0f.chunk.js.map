{"version":3,"sources":["utils/translate.ts","Translater.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["fetch","require","cache","langLst","API","API_KEY","translate","text","lang","Promise","resolve","reject","api_key","url","URL","searchParams","append","generate_url","toString","then","response","json","data","catch","err","getLangList","api_url","ui","a","method","getSupportedLangList","code","message","result","getCache","Translater","useState","input","translated","setupLang","translateDirection","state","setState","inputForm","React","createRef","useEffect","setInterval","console","log","current","value","newState","Object","assign","className","ref","onInput","e","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","error"],"mappings":"gbACMA,G,MAAQC,EAAQ,KAGlBC,EAAiB,GACfC,EAAmB,GACnBC,EAAM,0DACNC,EAAU,uFAYT,SAASC,EACdC,EACAC,GAIA,OAAIN,EAAM,GAAD,OAAIK,EAAJ,eAAeC,IACf,IAAIC,SAAQ,SAACC,EAASC,GAAV,OAAqBD,EAAQR,EAAM,GAAD,OAAIK,EAAJ,eAAeC,QAG/DR,EAnBT,SAAsBO,EAAcK,EAAiBJ,GACnD,IAAIK,EAAM,IAAIC,IAAIV,GAIlB,OAHAS,EAAIE,aAAaC,OAAO,MAAOJ,GAC/BC,EAAIE,aAAaC,OAAO,OAAQR,GAChCK,EAAIE,aAAaC,OAAO,OAAQT,GACzBM,EAcMI,CAAaV,EANFF,uFAMiBG,GAAMU,YAC5CC,MAAK,SAACC,GAAD,OAAmBA,EAASC,UACjCF,MAAK,SAACG,GAEL,OADApB,EAAM,GAAD,OAAIK,EAAJ,eAAeC,IAAUc,EACvBA,KAERC,OAAM,SAACC,GAEN,OADAtB,EAAM,GAAD,OAAIK,EAAJ,eAAeC,IAAUgB,EACvBA,K,SAIEC,E,gFAAf,WAA2BC,EAAiBC,GAA5C,SAAAC,EAAA,+EACS5B,EAAM0B,EAAS,CAAEG,OAAQ,SAC7BV,MAAK,SAACC,GAAD,OAAmBA,EAASC,UACjCF,MAAK,SAACG,GAEL,OADAnB,EAAQwB,GAAML,EACPA,KAERC,OAAM,SAACC,GACN,OAAOA,MARb,4C,sBAYO,SAAeM,EAAtB,kC,4CAAO,WAAoCH,GAApC,iBAAAC,EAAA,yDAC4B,CAC/BG,KAAM,IACNC,QAAS,oBAGP7B,EAAQwB,GANP,yCAOIxB,EAAQwB,IAPZ,cAUDD,EAVC,UAUYtB,EAVZ,yBAUgCC,EAVhC,eAU8CsB,GAV9C,SAYqCF,EAAYC,EAASC,GAZ1D,cAYDM,EAZC,yBAcEA,GAdF,4C,sBAiBA,IAAMC,EAAW,kBAAMhC,GC5B9B,IA0CeiC,EA1Cc,WACzB,IAD+B,EAOLC,mBANV,CACZC,MAAO,GACPC,WAAY,GACZC,UAAW,KACXC,mBAAoB,OALO,mBAOxBC,EAPwB,KAOjBC,EAPiB,KAQ3BC,EAAYC,IAAMC,YActB,OAZAC,qBAAU,WACNC,aAAY,WAAK,IAAD,EAEZ,GADAC,QAAQC,IAAIN,IACT,UAAAA,EAAUO,eAAV,eAAmBC,QAASV,EAAMJ,MAAO,CAAC,IAAD,EACpCe,EAA4BC,OAAOC,OAAO,GAAIb,GAC5ClC,EAAO8C,OAAOC,OAAO,GAAd,UAAkBX,EAAUO,eAA5B,aAAkB,EAAmBC,OAClDC,EAASf,MAAQ9B,EACjBmC,EAASU,MAGd,OACJ,IAEC,yBAAKG,UAAU,oBACX,yBAAKA,UAAU,eACX,2CAAiBd,EAAMF,WACvB,8BACAiB,IAAKb,EACLY,UAAU,QAAQE,QACd,SAACC,QAKT,yBAAKH,UAAU,gBACX,yCAAed,EAAMD,oBACrB,8BAAUe,UAAU,SAASJ,MAAOV,EAAMH,gBChE3CqB,EATO,WACpB,OACE,yBAAKJ,UAAU,OACb,6CACA,kBAAC,EAAD,QCGcK,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDiIpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBrD,MAAK,SAAAsD,GACJA,EAAaC,gBAEdnD,OAAM,SAAAoD,GACL3B,QAAQ2B,MAAMA,EAAM3C,c","file":"static/js/main.536c6b0f.chunk.js","sourcesContent":["import * as T from './types'\nconst fetch = require('node-fetch')\n\n\nlet cache: T.Cache = {}\nconst langLst: T.Cache = {}\nconst API = 'https://translate.yandex.net/api/v1.5/tr.json/translate'\nconst API_KEY = 'trnsl.1.1.20200419T183046Z.854d48023a74da23.b94456cd112cae9a9311e51a5d6f83f7c0b72961'\n\n\nfunction generate_url(text: string, api_key: string, lang: string): URL {\n  var url = new URL(API)\n  url.searchParams.append('key', api_key)\n  url.searchParams.append('lang', lang)\n  url.searchParams.append('text', text)\n  return url\n}\n\n// const someFunction = () => {};\nexport function translate(\n  text: string,\n  lang: string, // translation direction\n): Promise<T.ITranslateAPIResponse | T.IAPIResponseError> {\n  const api_key: string = API_KEY;\n\n  if (cache[`${text}::::${lang}`]) {\n    return new Promise((resolve, reject) => resolve(cache[`${text}::::${lang}`] as T.ITranslateAPIResponse))\n  }\n\n  return fetch(generate_url(text, api_key, lang).toString())\n    .then((response: any) => response.json())\n    .then((data: T.ITranslateAPIResponse) => {\n      cache[`${text}::::${lang}`] = data\n      return data\n    })\n    .catch((err: T.IAPIResponseError) => {\n      cache[`${text}::::${lang}`] = err\n      return err\n    })\n}\n\nasync function getLangList(api_url: string, ui: string): Promise<T.LangListAPIResponse> {\n  return fetch(api_url, { method: 'POST' })\n    .then((response: any) => response.json())\n    .then((data: T.ILangListAPIResponse) => {\n      langLst[ui] = data\n      return data\n    })\n    .catch((err: T.IAPIResponseError) => {\n      return err\n    })\n}\n\nexport async function getSupportedLangList(ui: string): Promise<T.LangListAPIResponse> {\n  let error: T.IAPIResponseError = {\n    code: 401,\n    message: 'Network problem',\n  }\n\n  if (langLst[ui]) {\n    return langLst[ui] as T.ILangListAPIResponse\n  }\n\n  let api_url = `${API}/getLangs?key=${API_KEY}&ui=${ui}`\n\n  let result: T.LangListAPIResponse = await getLangList(api_url, ui)\n\n  return result\n}\n\nexport const getCache = () => cache\n","import React, {useState, useEffect} from 'react';\nimport './Translater.css';\nimport TranslateUtils from './utils/index'\nimport * as trTypes from './utils/types'\nimport { translate } from '../../ts/utils/translate';\nimport { stat } from 'fs';\n\n\nconst selectLang: React.FC = (TranStat, SetTransState) => {\n    const langList = TranslateUtils.getSupportedLangList(\"en\")\n\n    return (\n        <select>\n            {}\n        </select>\n    )\n}\n\n\ninterface ITranslateState {\n    input: string | undefined,\n    translated: string;\n    setupLang: string;\n    translateDirection: string;\n}\n\nasync function TranslateText(\n    text: string | undefined,\n    state: ITranslateState,\n    setState: React.Dispatch<React.SetStateAction<ITranslateState>>,\n    ) {\n    TranslateUtils.translate(text as string, state.translateDirection).then(\n        (translated)=>{\n            let newState: ITranslateState = Object.assign({}, state);\n            let trText: string = (translated as trTypes.ITranslateAPIResponse).text[0];\n            newState.translated = trText;\n            setState(newState)\n            console.log(state)\n        }\n    )\n}\n\nconst Translater: React.FC = () => {\n    let initState = {\n        input: \"\",\n        translated: '',\n        setupLang: 'ru',\n        translateDirection: 'en',\n    }\n    const [state, setState] = useState<ITranslateState>(initState as ITranslateState)\n    let inputForm = React.createRef<HTMLTextAreaElement>();\n    // start monitoring user input \n    useEffect(() => {\n        setInterval(()=>{\n            console.log(inputForm)\n            if(inputForm.current?.value != state.input) {\n                let newState: ITranslateState = Object.assign({}, state);\n                const text = Object.assign({}, inputForm.current?.value)\n                newState.input = text\n                setState(newState)\n                //TranslateText(newState.input, state as ITranslateState, setState)\n            }\n        }, 2000)\n    }, [])\n    return (\n        <div className=\"TranslaterHolder\">\n            <div className=\"InputHolder\">\n                <p>source lang: {state.setupLang}</p>\n                <textarea\n                ref={inputForm}\n                className=\"Input\" onInput={\n                    (e)=>{\n                        \n                    }\n                }/>\n            </div>\n            <div className=\"OutputHolder\">\n                <p>dest lang: {state.translateDirection}</p>\n                <textarea className=\"Output\" value={state.translated}/>\n            </div>\n        </div>\n    )\n}\n\nexport default Translater;","import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport Translater from './Translater';\n\nconst App: React.FC = () => {\n  return (\n    <div className=\"App\">\n      <h1>TT Translater</h1>\n      <Translater />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}