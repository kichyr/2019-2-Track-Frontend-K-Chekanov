{"version":3,"sources":["utils/translate.ts","utils/index.ts","Translater.tsx","useInterval.js","App.tsx","serviceWorker.ts","index.tsx"],"names":["fetch","require","cache","langLst","API","API_KEY","translate","text","lang","Promise","resolve","reject","api_key","url","URL","searchParams","append","generate_url","toString","then","response","json","data","catch","err","getLangList","api_url","ui","a","getSupportedLangList","code","message","result","getCache","TranslateUtils","SelectLang","props","useState","state","setState","useEffect","initialState","langs","selectJSX","push","onChange","e","langName","target","value","newTranState","Object","assign","TranState","isSource","trSource","trDest","SetTransState","translated","newState","trText","Translater","input","inputForm","useRef","callback","delay","savedCallback","current","id","setInterval","clearInterval","useInterval","TranslateText","console","log","className","ref","onInput","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","error"],"mappings":"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","file":"static/js/main.205d6d0e.chunk.js","sourcesContent":["import * as T from './types'\nconst fetch = require('node-fetch')\n\n\nlet cache: T.Cache = {}\nconst langLst: T.Cache = {}\nconst API = 'https://translate.yandex.net/api/v1.5/tr.json'\nconst API_KEY = 'trnsl.1.1.20200419T183046Z.854d48023a74da23.b94456cd112cae9a9311e51a5d6f83f7c0b72961'\n\n\nfunction generate_url(text: string, api_key: string, lang: string): URL {\n  var url = new URL(API+'/translate')\n  url.searchParams.append('key', api_key)\n  url.searchParams.append('lang', lang)\n  url.searchParams.append('text', text)\n  return url\n}\n\n// const someFunction = () => {};\nexport function translate(\n  text: string,\n  lang: string, // translation direction\n): Promise<T.ITranslateAPIResponse | T.IAPIResponseError> {\n  const api_key: string = API_KEY;\n\n  if (cache[`${text}::::${lang}`]) {\n    return new Promise((resolve, reject) => resolve(cache[`${text}::::${lang}`] as T.ITranslateAPIResponse))\n  }\n\n  return fetch(generate_url(text, api_key, lang).toString())\n    .then((response: any) => response.json())\n    .then((data: T.ITranslateAPIResponse) => {\n      cache[`${text}::::${lang}`] = data\n      return data\n    })\n    .catch((err: T.IAPIResponseError) => {\n      cache[`${text}::::${lang}`] = err\n      return err\n    })\n}\n\nasync function getLangList(api_url: string, ui: string): Promise<T.LangListAPIResponse> {\n  return (fetch(api_url)\n    .then((response: any) => response.json())\n    .then((data: T.ILangListAPIResponse) => {\n      langLst[ui] = data\n      return data\n    })\n    .catch((err: T.IAPIResponseError) => {\n      return err\n    }));\n}\n\nexport async function getSupportedLangList(ui: string): Promise<T.LangListAPIResponse> {\n  let error: T.IAPIResponseError = {\n    code: 401,\n    message: 'Network problem',\n  }\n\n  if (langLst[ui]) {\n    return langLst[ui] as T.ILangListAPIResponse\n  }\n\n  let api_url = `${API}/getLangs?key=${API_KEY}&ui=${ui}`\n\n  let result: T.LangListAPIResponse = await getLangList(api_url, ui)\n\n  return result\n}\n\nexport const getCache = () => cache\n","import * as TranslateUtils from './translate'\n\nexport default TranslateUtils\n","import React, {useState, useEffect, useRef} from 'react';\nimport './Translater.css';\nimport TranslateUtils from './utils/index'\nimport * as trTypes from './utils/types'\nimport useInterval from './useInterval';\ninterface ISelectLangState {\n    langs: {[ind: string]:string}\n}\n\n\n\ninterface Props {\n    isSource: boolean, //with or without auto option\n    TranState: ITranslateState,\n    SetTransState: React.Dispatch<React.SetStateAction<ITranslateState>>\n}\n  \nconst SelectLang: React.FC<Props> = ((props) => {\n    const [state, setState] = useState<ISelectLangState>();\n    useEffect(() => {\n        TranslateUtils.getSupportedLangList(\"en\")\n        .then((response) => {\n            let initialState = {\n                langs: (response as trTypes.ILangListAPIResponse).langs \n            }\n            setState(initialState as ISelectLangState)\n        })\n    }, []);\n\n    let selectJSX: JSX.Element[] = [];\n    for (const lang in state?.langs) {\n        selectJSX.push(\n            (<option> {state?.langs[lang]} </option>)\n        )\n    }\n    return (\n        <select onChange={(e)=>{\n            const langName = e.target.value;\n            for (const lang in state?.langs) {\n                if(state?.langs[lang] === langName) {\n                    let newTranState = Object.assign({}, props.TranState);\n                    if(props.isSource)\n                        newTranState.trSource = lang;\n                    else\n                        newTranState.trDest = lang;\n                    props.SetTransState(newTranState);\n                    return\n                }\n            }\n            // change mode on auto mode\n            if(props.isSource) {\n                let newTranState = Object.assign({}, props.TranState);\n                newTranState.trSource = \"\";\n                props.SetTransState(newTranState);\n            }\n        }}>\n            {props.isSource && <option> auto </option>}\n            {selectJSX}\n        }\n        </select>\n    )\n})\n\n\ninterface ITranslateState {\n    input: string | undefined,\n    translated: string;\n    trDest: string;\n    trSource: string\n}\n\nasync function TranslateText(\n    text: string | undefined,\n    state: ITranslateState,\n    setState: React.Dispatch<React.SetStateAction<ITranslateState>>,\n    ) {\n    TranslateUtils.translate(\n        text as string,\n        state.trSource == \"\" ? state.trDest : state.trSource + '-' + state.trDest,\n        ).then(\n        (translated)=>{\n            let newState: ITranslateState = Object.assign({}, state);\n            let trText: string = (translated as trTypes.ITranslateAPIResponse).text[0];\n            newState.translated = trText;\n            setState(newState)\n        }\n    )\n}\n\nconst Translater: React.FC = () => {\n    let initState = {\n        input: \"\",\n        translated: '',\n        trDest: 'en',\n        trSource: '', // empty string means auto detection\n    }\n    const [state, setState] = useState<ITranslateState>(initState as ITranslateState)\n    let inputForm: React.RefObject<HTMLTextAreaElement> = useRef<HTMLTextAreaElement>(null) \n    // start monitoring user input \n    useInterval(updateTransText, 1000);\n    useEffect(() => {\n    }, [])\n    function updateTransText() {\n        if(inputForm.current?.value != state.input) {\n            let newState: ITranslateState = Object.assign({}, state);\n            newState.input = inputForm.current?.value\n            setState(newState)\n            TranslateText(newState.input, state as ITranslateState, setState)\n            console.log(state);\n        }\n    }\n    return (\n        <div className=\"TranslaterHolder\">\n            <div className=\"InputHolder\">\n                <p>source lang: \n                    <SelectLang isSource={true} TranState={state} SetTransState={setState} /></p>\n                <textarea\n                ref={inputForm}\n                className=\"Input\" onInput={\n                    (e)=>{\n                        \n                    }\n                }/>\n            </div>\n            <div className=\"OutputHolder\">\n                <p>\n                    dest lang: <SelectLang isSource={false} TranState={state} SetTransState={setState}></SelectLang> \n                </p>\n                <textarea className=\"Output\" value={state.translated}/>\n            </div>\n        </div>\n    )\n}\n\nexport default Translater;","\nimport {useEffect, useRef} from 'react';\n\nexport default function useInterval(callback, delay) {\n    const savedCallback = useRef();\n  \n    // Remember the latest callback.\n    useEffect(() => {\n      savedCallback.current = callback;\n    }, [callback]);\n  \n    // Set up the interval.\n    useEffect(() => {\n      function tick() {\n        savedCallback.current();\n      }\n      if (delay !== null) {\n        let id = setInterval(tick, delay);\n        return () => clearInterval(id);\n      }\n    }, [delay]);\n  }","import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport Translater from './Translater';\n\nconst App: React.FC = () => {\n  return (\n    <div className=\"App\">\n      <h1>TT Translater</h1>\n      <Translater />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}